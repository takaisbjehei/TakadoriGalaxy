<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TakaGalaxy Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f2f5;
    }
    .chat-container {
      display: flex;
      height: 100vh;
    }
    .sidebar {
      width: 300px;
      background-color: #fff;
      border-right: 1px solid #e2e8f0;
      display: flex;
      flex-direction: column;
      position: relative; /* For the new chat modal */
      z-index: 10;
    }
    .chat-area {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      background-color: #f9fafb;
    }
    .header, .chat-header {
      padding: 1rem;
      border-bottom: 1px solid #e2e8f0;
      background-color: #fff;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .chat-header {
        justify-content: flex-start;
    }
    .user-list {
      flex-grow: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }
    .user-card {
      display: flex;
      align-items: center;
      padding: 0.75rem;
      margin-bottom: 0.25rem;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .user-card:hover {
      background-color: #f0f2f5;
    }
    .user-card.active {
      background-color: #e0f2fe; /* Light blue for active user */
    }
    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: #6366f1; /* Indigo */
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.1rem;
      flex-shrink: 0;
    }
    .user-info {
      margin-left: 0.75rem;
      flex-grow: 1;
    }
    .user-name {
      font-weight: 600;
      color: #1a202c;
    }
    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin-left: 0.5rem;
    }
    .status-indicator.online {
      background-color: #10b981; /* Emerald */
    }
    .status-indicator.offline {
      background-color: #ef4444; /* Red */
    }
    .status-text {
        font-size: 0.75rem;
        color: #6b7280;
    }
    .messages-container {
      flex-grow: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      background-color: #f0f2f5;
    }
    .message-input-area {
      padding: 1rem;
      border-top: 1px solid #e2e8f0;
      background-color: #fff;
      display: flex;
      align-items: center;
    }
    .message-input {
      flex-grow: 1;
      border: 1px solid #cbd5e0;
      border-radius: 0.5rem;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      resize: none;
      min-height: 40px; /* Ensure a minimum height */
      max-height: 150px; /* Max height before scrolling */
      overflow-y: auto;
    }
    .message-input:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }
    .send-button {
      margin-left: 1rem;
      background-color: #6366f1;
      color: #fff;
      padding: 0.75rem 1.25rem;
      border-radius: 0.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .send-button:hover {
      background-color: #4f46e5;
    }

    /* Message bubbles */
    .message-bubble {
      max-width: 70%;
      padding: 0.75rem 1rem;
      border-radius: 1rem;
      word-wrap: break-word;
    }
    .message-bubble.sent {
      align-self: flex-end;
      background-color: #6366f1; /* Indigo */
      color: #fff;
      border-bottom-right-radius: 0.25rem;
    }
    .message-bubble.received {
      align-self: flex-start;
      background-color: #e2e8f0; /* Light gray */
      color: #1a202c;
      border-bottom-left-radius: 0.25rem;
    }
    .message-time {
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.7); /* For sent messages */
    }
    .message-bubble.received .message-time {
        color: rgba(0, 0, 0, 0.5); /* For received messages */
    }

    /* Modals */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal-content {
      background-color: #fff;
      padding: 2rem;
      border-radius: 0.75rem;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      position: relative;
    }
    .modal-close-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #6b7280;
    }
    .modal-close-btn:hover {
      color: #1a202c;
    }
    .search-input {
      width: 100%;
      padding: 0.75rem 1rem;
      border: 1px solid #cbd5e0;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
    }
    .user-selection-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 0.5rem;
    }
    .modal-user-card {
        padding: 0.75rem;
        display: flex;
        align-items: center;
        border-bottom: 1px solid #e2e8f0;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    .modal-user-card:last-child {
        border-bottom: none;
    }
    .modal-user-card:hover {
        background-color: #f0f2f5;
    }
    .modal-user-card .avatar {
        width: 36px;
        height: 36px;
        font-size: 1rem;
    }
    .modal-user-card .user-name {
        font-size: 0.95rem;
    }

    /* Utility classes */
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div class="sidebar">
      <div class="header">
        <div class="flex items-center space-x-3">
          <div id="userAvatar" class="avatar">U</div>
          <div>
            <div class="font-bold text-lg text-gray-800">You</div>
            <div id="userStatus" class="text-sm text-gray-600 capitalize">Offline</div>
          </div>
        </div>
        <div class="flex items-center space-x-2">
            <button id="addChatBtn" class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100 transition-colors" title="Start new chat">
                <i class="fas fa-plus"></i>
            </button>
            <button id="logoutBtn" class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100 transition-colors" title="Logout">
                <i class="fas fa-sign-out-alt"></i>
            </button>
        </div>
      </div>

      <div class="p-4 border-b border-gray-200">
        <input type="text" id="conversationSearch" placeholder="Search conversations..." class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
      </div>

      <div id="userList" class="user-list">
        <div class="text-center text-gray-500 py-8">
            <i class="fas fa-users text-3xl mb-4"></i>
            <p>No conversations yet.</p>
        </div>
      </div>
    </div>

    <div class="chat-area">
      <div id="chatHeader" class="chat-header">
        <div class="flex items-center">
            <div id="chatAvatar" class="avatar hidden"></div>
            <div class="user-info ml-3">
                <div id="chatUserName" class="user-name text-gray-800">Select a user to chat</div>
                <div id="chatUserStatus" class="text-xs text-gray-500 hidden"></div>
            </div>
            <div id="typingIndicator" class="ml-4 text-sm text-gray-500 hidden">
                <i class="fas fa-ellipsis-h animate-pulse mr-1"></i> typing...
            </div>
        </div>
      </div>

      <div id="messagesContainer" class="messages-container">
        <div class="text-center text-gray-500 text-sm py-8">
            <i class="fas fa-comments text-3xl mb-4"></i>
            <p>Start a conversation by selecting a user</p>
        </div>
      </div>

      <div class="message-input-area border-t border-gray-200">
        <textarea id="messageInput" placeholder="Type your message..." class="message-input" rows="1"></textarea>
        <button id="sendBtn" class="send-button">
          <i class="fas fa-paper-plane mr-2"></i>Send
        </button>
      </div>
    </div>
  </div>

  <div id="newChatModal" class="modal-overlay hidden">
    <div class="modal-content">
      <button class="modal-close-btn" onclick="closeNewChatModal()">&times;</button>
      <h2 class="text-2xl font-semibold mb-4 text-gray-800">Start New Chat</h2>
      <input type="text" id="allUserSearch" placeholder="Search users..." class="search-input">
      <div id="allUserList" class="user-selection-list">
        <div class="text-center text-gray-500 py-8">
            <i class="fas fa-user-slash text-3xl mb-4"></i>
            <p>No other users found.</p>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Supabase configuration
    const supabaseUrl = 'https://vmronlbzksuiikspvlvz.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZtcm9ubGJ6a3N1aWlrc3B2bHZ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk5ODMwNTcsImV4cCI6MjA2NTU1OTA1N30.WMKbpJn1aavkwQDmsYq_-4EMSLL9tc4LexpmRSCsmSM';
    const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

    // Global state
    let currentUser = null;
    let selectedUser = null;
    let usernameSet = false;
    let conversationUsers = [];
    let allAvailableUsers = [];
    let realtimeSubscription = null; // For real-time updates
    let typingTimeout = null; // For typing indicator

    // Initialize the application
    async function initApp() {
      try {
        // Check auth status
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
          window.location.href = 'index.html'; // Redirect to login if not authenticated
          return;
        }

        currentUser = user;

        // Set user avatar initially
        const firstLetter = user.email ? user.email.charAt(0).toUpperCase() : 'U';
        document.getElementById('userAvatar').textContent = firstLetter;

        // Check if username is set (and fetch it if available)
        await checkUsername();

        // Set up real-time subscriptions
        setupRealtimeSubscriptions();

        // Set user status to online
        updateUserStatus(true);

        // Load conversation users and all available users
        await loadConversationUsers();
        await loadAllUsers(); 

        // Set up event listeners
        setupEventListeners();

      } catch (error) {
        console.error('Initialization error:', error);
        alert('Failed to initialize app. Check console for details.');
      }
    }

    // Set up real-time subscriptions
    function setupRealtimeSubscriptions() {
      // Unsubscribe from any existing subscriptions
      if (realtimeSubscription) {
        supabase.removeChannel(realtimeSubscription);
      }

      // Subscribe to messages where THIS USER IS THE RECEIVER
      realtimeSubscription = supabase
        .channel('messages')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'messages',
            filter: `receiver_id=eq.${currentUser.id}` // Only listen for messages *received* by current user
          },
          (payload) => {
            console.log('Realtime message received:', payload.new);
            // Check if the message is from the currently selected user
            if (selectedUser && payload.new.sender_id === selectedUser.id) {
              addMessageToUI(payload.new);
              scrollToBottom();
              // Mark message as read if it's currently open
              markMessagesAsRead(payload.new.sender_id);
            }
            
            // Always update conversation list when a new message is received
            loadConversationUsers(); 
          }
        )
        .on(
          'postgres_changes',
          {
            event: 'UPDATE',
            schema: 'public',
            table: 'profiles',
            filter: `id=neq.${currentUser.id}` // Listen for status changes of other users
          },
          (payload) => {
            // Update user status in UI
            updateUserStatusUI(payload.new);
            // If the updated user is the selected user, update their chat header status
            if (selectedUser && selectedUser.id === payload.new.id) {
                document.getElementById('chatUserStatus').textContent = payload.new.status || 'offline';
                document.getElementById('chatUserStatus').className = `text-xs capitalize ${payload.new.status === 'online' ? 'text-green-500' : 'text-gray-500'}`;
            }
          }
        )
        .subscribe();
    }

    // This function will be called when a user is selected from the left sidebar or "New Chat" modal
    async function selectUser(user) {
        selectedUser = user;

        // Update active class for user cards
        document.querySelectorAll('.user-card').forEach(card => {
            card.classList.remove('active');
            if (card.getAttribute('data-user-id') === user.id) {
                card.classList.add('active');
            }
        });

        // Update chat header
        document.getElementById('chatAvatar').textContent = user.username ? user.username.charAt(0).toUpperCase() : user.email.charAt(0).toUpperCase();
        document.getElementById('chatAvatar').classList.remove('hidden');
        document.getElementById('chatUserName').textContent = user.username || user.email.split('@')[0];
        document.getElementById('chatUserStatus').textContent = user.status || 'offline';
        document.getElementById('chatUserStatus').classList.remove('hidden');
        document.getElementById('chatUserStatus').className = `text-xs capitalize ${user.status === 'online' ? 'text-green-500' : 'text-gray-500'}`;


        // Show message input and send button
        document.getElementById('messageInput').closest('.message-input-area').classList.remove('hidden');

        // Close new chat modal if open
        closeNewChatModal();
        
        // Load messages for the selected user
        await loadMessages();
        await markMessagesAsRead(user.id);
        await loadConversationUsers(); // Refresh conversation list to update unread counts
    }

    // Update user status in UI (for sidebar users)
    function updateUserStatusUI(user) {
      // Find all user cards with this user
      const userCards = document.querySelectorAll('.user-card');
      userCards.forEach(card => {
        const userId = card.getAttribute('data-user-id');
        if (userId === user.id) {
          const statusIndicator = card.querySelector('.status-indicator');
          const statusText = card.querySelector('.status-text');
          if (statusIndicator) {
            statusIndicator.className = `status-indicator ${user.status === 'online' ? 'online' : 'offline'}`;
          }
          if (statusText) {
            statusText.textContent = user.status || 'offline';
          }
        }
      });
      
      // Update chat header if it's the selected user
      if (selectedUser && selectedUser.id === user.id) {
        document.getElementById('chatUserStatus').textContent = user.status || 'offline';
        document.getElementById('chatUserStatus').className = `text-xs capitalize ${user.status === 'online' ? 'text-green-500' : 'text-gray-500'}`;

        const typingIndicator = document.getElementById('typingIndicator');
        if (typingIndicator) {
          typingIndicator.classList.add('hidden'); // Hide typing indicator on status change
        }
      }
    }

    // Load messages between current user and selected user
    async function loadMessages() {
      try {
        const messagesContainer = document.getElementById('messagesContainer');
        messagesContainer.innerHTML = ''; // Clear current messages

        if (!selectedUser) {
          messagesContainer.innerHTML = `
            <div class="text-center text-gray-500 text-sm py-8">
              <i class="fas fa-comments text-3xl mb-4"></i>
              <p>Start a conversation by selecting a user</p>
            </div>
          `;
          document.getElementById('messageInput').closest('.message-input-area').classList.add('hidden'); // Hide input
          return;
        }
        document.getElementById('messageInput').closest('.message-input-area').classList.remove('hidden'); // Show input

        const { data: messages, error } = await supabase
          .from('messages')
          .select('*')
          .or(`and(sender_id.eq.${currentUser.id},receiver_id.eq.${selectedUser.id}),and(sender_id.eq.${selectedUser.id},receiver_id.eq.${currentUser.id})`)
          .order('created_at', { ascending: true });

        if (error) throw error;

        if (!messages || messages.length === 0) {
          messagesContainer.innerHTML = `
            <div class="text-center text-gray-500 text-sm py-8">
              <i class="fas fa-comment-slash text-3xl mb-4"></i>
              <p>No messages yet. Start the conversation!</p>
            </div>
          `;
          return;
        }

        messages.forEach(message => {
          addMessageToUI(message);
        });

        // Scroll to bottom
        scrollToBottom();

      } catches (error) {
        console.error('Load messages error:', error);
        messagesContainer.innerHTML = `
          <div class="text-center text-red-400 text-sm py-8">
            <i class="fas fa-exclamation-triangle text-3xl mb-4"></i>
            <p>Error loading messages.</p>
          </div>
        `;
      }
    }

    // Add message to UI
    function addMessageToUI(message) {
      const isCurrentUser = message.sender_id === currentUser.id;
      const messagesContainer = document.getElementById('messagesContainer');

      // Remove the "no messages" placeholder if it exists
      if (messagesContainer.children.length === 1 && 
          messagesContainer.children[0].classList.contains('text-center')) {
        messagesContainer.innerHTML = '';
      }

      const messageElement = document.createElement('div');
      messageElement.className = `message-bubble ${isCurrentUser ? 'sent' : 'received'} flex flex-col`;

      messageElement.innerHTML = `
        <div class="message-text">${message.content}</div>
        <div class="message-time text-xs opacity-70 mt-1 ${isCurrentUser ? 'self-end' : 'self-start'}">${formatTime(message.created_at)}</div>
      `;

      messagesContainer.appendChild(messageElement);
    }

    // Scroll to the bottom of the messages container
    function scrollToBottom() {
      const messagesContainer = document.getElementById('messagesContainer');
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // Format time for display
    function formatTime(dateString) {
      try {
        const date = new Date(dateString);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch {
        return 'Now';
      }
    }

    // Send message
    async function sendMessage() {
      try {
        const content = messageInput.value.trim();
        if (!content || !selectedUser || !currentUser) return;

        // Clear input immediately
        messageInput.value = '';
        
        // Create message object for UI (for immediate display)
        const tempMessage = {
          id: `temp-${Date.now()}`,
          sender_id: currentUser.id,
          receiver_id: selectedUser.id,
          content: content,
          created_at: new Date().toISOString()
        };

        // Add sender's message to UI immediately
        addMessageToUI(tempMessage);
        scrollToBottom();

        // Insert message to database
        const { error } = await supabase
          .from('messages')
          .insert({
            sender_id: currentUser.id,
            receiver_id: selectedUser.id,
            content: content,
            read: false // Mark as unread for the receiver
          });

        if (error) throw error;

        // After sending, update the conversation list to ensure the recipient appears
        // at the top if they weren't already there.
        await loadConversationUsers();

      } catch (error) {
        console.error('Send message error:', error);
        alert('Failed to send message. Please try again.');
      }
    }

    // Typing indicator
    function handleTyping() {
        const typingIndicator = document.getElementById('typingIndicator');
        // Only show typing indicator if a user is selected
        if (selectedUser) {
            // This is a simplified client-side typing indicator.
            // For a robust solution, you'd send a broadcast to Supabase
            // and listen for other users' typing broadcasts.
            typingIndicator.classList.remove('hidden');
        }

        // Clear any existing timeout
        if (typingTimeout) clearTimeout(typingTimeout);
        
        // Set new timeout to hide typing indicator after 2 seconds of inactivity
        typingTimeout = setTimeout(() => {
            if (typingIndicator) {
                typingIndicator.classList.add('hidden');
            }
        }, 2000); // Hide after 2 seconds of no typing
    }

    // Update user status (online/offline)
    async function updateUserStatus(isOnline) {
      try {
        const status = isOnline ? 'online' : 'offline';
        document.getElementById('userStatus').textContent = status;
        
        // Update user status in Supabase
        const { error } = await supabase
          .from('profiles')
          .update({ status: status })
          .eq('id', currentUser.id);

        if (error) throw error;

      } catch (error) {
        console.error('Update status error:', error);
      }
    }

    // Function to load conversation users (users current user has chatted with)
    async function loadConversationUsers() {
        try {
            // Fetch users current user has sent messages to
            const { data: sentMessagesUsers, error: sentError } = await supabase
                .from('messages')
                .select('receiver_id')
                .eq('sender_id', currentUser.id)
                .neq('receiver_id', currentUser.id); // Exclude self-conversations for now

            if (sentError) throw sentError;

            // Fetch users current user has received messages from
            const { data: receivedMessagesUsers, error: receivedError } = await supabase
                .from('messages')
                .select('sender_id, read')
                .eq('receiver_id', currentUser.id)
                .neq('sender_id', currentUser.id); // Exclude self-conversations for now

            if (receivedError) throw receivedError;

            const chattedUserIds = new Set();
            const unreadCounts = {};

            sentMessagesUsers.forEach(msg => chattedUserIds.add(msg.receiver_id));
            receivedMessagesUsers.forEach(msg => {
                chattedUserIds.add(msg.sender_id);
                if (!msg.read) {
                    unreadCounts[msg.sender_id] = (unreadCounts[msg.sender_id] || 0) + 1;
                }
            });

            if (chattedUserIds.size === 0) {
                document.getElementById('userList').innerHTML = `
                    <div class="text-center text-gray-500 py-8">
                        <i class="fas fa-users text-3xl mb-4"></i>
                        <p>No conversations yet.</p>
                    </div>
                `;
                conversationUsers = [];
                return;
            }

            const { data: profiles, error: profilesError } = await supabase
                .from('profiles')
                .select('id, username, email, status')
                .in('id', Array.from(chattedUserIds));

            if (profilesError) throw profilesError;

            // Attach unread counts to profiles
            const conversationsWithUnread = profiles.map(profile => ({
                ...profile,
                unreadCount: unreadCounts[profile.id] || 0
            }));

            // Sort conversations by unread messages then alphabetically
            conversationsWithUnread.sort((a, b) => {
                if (a.unreadCount > 0 && b.unreadCount === 0) return -1;
                if (b.unreadCount > 0 && a.unreadCount === 0) return 1;
                return (a.username || a.email).localeCompare(b.username || b.email);
            });


            conversationUsers = conversationsWithUnread;
            renderUsers(conversationUsers, document.getElementById('userList'), selectUser);

        } catch (error) {
            console.error('Error loading conversation users:', error);
            document.getElementById('userList').innerHTML = `
                <div class="text-center text-red-400 py-8">
                    <i class="fas fa-exclamation-triangle text-3xl mb-4"></i>
                    <p>Error loading conversations.</p>
                </div>
            `;
        }
    }

    // Function to load all available users (for new chat modal)
    async function loadAllUsers() {
        try {
            const { data: users, error } = await supabase
                .from('profiles')
                .select('id, username, email, status')
                .neq('id', currentUser.id); // Exclude current user
            if (error) throw error;
            allAvailableUsers = users;
            renderUsers(allAvailableUsers, document.getElementById('allUserList'), selectUserFromModal);
        } catch (error) {
            console.error('Error loading all users:', error);
            document.getElementById('allUserList').innerHTML = `<div class="text-center text-red-400 py-8"><p>Error loading users.</p></div>`;
        }
    }

    // Generic function to render user lists
    function renderUsers(users, containerElement, clickHandler) {
        containerElement.innerHTML = ''; // Clear existing
        if (!users || users.length === 0) {
            containerElement.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i class="fas ${containerElement.id === 'userList' ? 'fa-users' : 'fa-user-slash'} text-3xl mb-4"></i>
                    <p>${containerElement.id === 'userList' ? 'No conversations yet.' : 'No other users found.'}</p>
                </div>
            `;
            return;
        }

        users.forEach(user => {
            const userCard = document.createElement('div');
            userCard.className = `user-card ${containerElement.id === 'allUserList' ? 'modal-user-card' : ''} ${selectedUser && selectedUser.id === user.id ? 'active' : ''}`;
            userCard.setAttribute('data-user-id', user.id);
            userCard.addEventListener('click', () => clickHandler(user));

            const firstLetter = (user.username || user.email).charAt(0).toUpperCase();
            const displayName = user.username || user.email.split('@')[0];
            
            userCard.innerHTML = `
                <div class="avatar">${firstLetter}</div>
                <div class="user-info">
                    <div class="user-name">${displayName} ${user.unreadCount && user.unreadCount > 0 ? `<span class="ml-2 px-2 py-0.5 bg-red-500 text-white rounded-full text-xs font-semibold">${user.unreadCount}</span>` : ''}</div>
                    <div class="status-text flex items-center">
                        <span class="status-indicator ${user.status === 'online' ? 'online' : 'offline'} mr-1"></span>
                        <span class="capitalize">${user.status || 'offline'}</span>
                    </div>
                </div>
            `;
            containerElement.appendChild(userCard);
        });
    }

    // Function to mark messages as read
    async function markMessagesAsRead(senderId) {
        try {
            const { error } = await supabase
                .from('messages')
                .update({ read: true }) // Ensure this matches your column name
                .eq('sender_id', senderId)
                .eq('receiver_id', currentUser.id)
                .eq('read', false); // Only update unread messages
            
            if (error) throw error;
            console.log(`Messages from ${senderId} marked as read.`);
        } catch (error) {
            console.error('Error marking messages as read:', error);
        }
    }

    // Open New Chat Modal
    function openNewChatModal() {
      document.getElementById('newChatModal').classList.remove('hidden');
      document.getElementById('allUserSearch').value = ''; // Clear search
      renderUsers(allAvailableUsers, document.getElementById('allUserList'), selectUserFromModal);
    }

    // Close New Chat Modal
    function closeNewChatModal() {
      document.getElementById('newChatModal').classList.add('hidden');
    }

    // Select user from New Chat modal
    function selectUserFromModal(user) {
        // Add the selected user to conversationUsers if not already present
        const existingConversation = conversationUsers.find(u => u.id === user.id);
        if (!existingConversation) {
            // If starting a new conversation, set unread count to 0 initially
            conversationUsers.unshift({ ...user, unreadCount: 0 }); 
        }
        selectUser(user); // Call the main selectUser function
        closeNewChatModal();
        loadConversationUsers(); // Re-render the sidebar to reflect new conversation order
    }

    // Filter conversation users based on search input
    function filterConversationUsers(searchTerm) {
        const filtered = conversationUsers.filter(user => 
            (user.username && user.username.toLowerCase().includes(searchTerm.toLowerCase())) ||
            (user.email && user.email.toLowerCase().includes(searchTerm.toLowerCase()))
        );
        renderUsers(filtered, document.getElementById('userList'), selectUser);
    }

    // Filter all users in New Chat modal based on search input
    function filterAllUsers(searchTerm) {
        const filtered = allAvailableUsers.filter(user =>
            (user.username && user.username.toLowerCase().includes(searchTerm.toLowerCase())) ||
            (user.email && user.email.toLowerCase().includes(searchTerm.toLowerCase()))
        );
        renderUsers(filtered, document.getElementById('allUserList'), selectUserFromModal);
    }

    // Check if username is set (and fetch it if available)
    async function checkUsername() {
        const { data: profile, error } = await supabase
            .from('profiles')
            .select('username')
            .eq('id', currentUser.id)
            .single();

        if (error || !profile || !profile.username) {
            console.warn('Username not set for current user. Consider prompting user to set it.');
            usernameSet = false;
        } else {
            document.getElementById('userAvatar').textContent = profile.username.charAt(0).toUpperCase();
            document.querySelector('.header .font-bold').textContent = profile.username;
            currentUser.username = profile.username; // Attach username to currentUser object
            usernameSet = true;
        }
    }


    // Set up event listeners
    function setupEventListeners() {
      // Send message
      document.getElementById('sendBtn').addEventListener('click', sendMessage);
      
      const messageInput = document.getElementById('messageInput');
      messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
      
      // Typing indicator
      messageInput.addEventListener('input', handleTyping);

      // Logout button
      document.getElementById('logoutBtn').addEventListener('click', async () => {
        try {
          await updateUserStatus(false);
          await supabase.auth.signOut();
          window.location.href = 'index.html';
        } catch (error) {
          console.error('Logout error:', error);
          alert('Logout failed. Please try again.');
        }
      });

      // Status updates (focus/blur)
      window.addEventListener('focus', () => updateUserStatus(true));
      window.addEventListener('blur', () => updateUserStatus(false));

      // Handle beforeunload
      window.addEventListener('beforeunload', async () => {
          // This uses a synchronous XHR to try and send the offline status.
          // This is generally discouraged but might be necessary for 'beforeunload' reliability.
          // For a more modern approach, consider using navigator.sendBeacon() or a WebSockets 'close' event.
          if (currentUser) {
              const xhr = new XMLHttpRequest();
              xhr.open('POST', `${supabaseUrl}/rest/v1/profiles?id=eq.${currentUser.id}`, false); // Synchronous
              xhr.setRequestHeader('Content-Type', 'application/json');
              xhr.setRequestHeader('apikey', supabaseKey);
              xhr.setRequestHeader('Authorization', `Bearer ${supabase.auth.getSession()?.access_token}`);
              xhr.send(JSON.stringify({ status: 'offline' }));
          }
          if (realtimeSubscription) {
              supabase.removeChannel(realtimeSubscription);
          }
      });

      // Search functionality for conversations
      const conversationSearch = document.getElementById('conversationSearch');
      conversationSearch.addEventListener('input', (e) => {
        filterConversationUsers(e.target.value.trim());
      });

      // Add Chat button
      document.getElementById('addChatBtn').addEventListener('click', openNewChatModal);

      // Search in New Chat modal
      const allUserSearch = document.getElementById('allUserSearch');
      allUserSearch.addEventListener('input', (e) => {
        filterAllUsers(e.target.value.trim());
      });

      // Auto-resize textarea
      messageInput.addEventListener('input', () => {
        messageInput.style.height = 'auto';
        messageInput.style.height = messageInput.scrollHeight + 'px';
      });

      // Close modal when clicking outside
      document.getElementById('newChatModal').addEventListener('click', (event) => {
          if (event.target.id === 'newChatModal') {
              closeNewChatModal();
          }
      });

    }

    // Initialize the app
    document.addEventListener('DOMContentLoaded', initApp);
    
    // Make functions globally accessible for onclick attributes in dynamically generated HTML
    window.selectUser = selectUser;
    window.closeNewChatModal = closeNewChatModal;
  </script>
</body>
</html>
