<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TakaGalaxy Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    /* Custom Scrollbar for better aesthetics */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* Message bubble styling */
    .message-bubble {
      max-width: 75%;
      padding: 10px 14px;
      border-radius: 20px;
      margin-bottom: 10px;
      word-wrap: break-word;
      white-space: pre-wrap; /* Preserve whitespace and breaks */
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .message-bubble.sent {
      background-color: #6366f1; /* Indigo 500 */
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 5px; /* Tweak for tail effect */
    }

    .message-bubble.received {
      background-color: #e2e8f0; /* Slate 200 */
      color: #333;
      align-self: flex-start;
      border-bottom-left-radius: 5px; /* Tweak for tail effect */
    }

    .message-time {
      font-size: 0.7rem;
      opacity: 0.8;
      color: rgba(255, 255, 255, 0.7); /* For sent messages */
    }

    .message-bubble.received .message-time {
      color: rgba(0, 0, 0, 0.5); /* For received messages */
    }

    /* Status indicators */
    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 4px;
    }
    .status-indicator.online {
      background-color: #10b981; /* Green 500 */
    }
    .status-indicator.offline {
      background-color: #ef4444; /* Red 500 */
    }

    /* Modal styles */
    .modal-overlay {
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 999;
    }
    .modal-content {
      animation: fadeIn 0.3s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body class="font-sans antialiased bg-gray-100 h-screen flex overflow-hidden">

  <!-- Main Chat Container -->
  <div class="flex flex-1 h-full max-h-screen">

    <!-- Left Sidebar - User List -->
    <aside class="w-1/3 md:w-1/4 bg-white border-r border-gray-200 flex flex-col shadow-lg">
      <div class="p-4 bg-indigo-600 text-white flex items-center justify-between rounded-tl-lg">
        <div class="flex items-center">
          <div id="userAvatar" class="w-10 h-10 rounded-full bg-indigo-800 flex items-center justify-center text-lg font-bold mr-3 border-2 border-white">U</div>
          <div class="flex flex-col">
            <span id="userName" class="font-semibold text-lg">Loading...</span>
            <span id="userStatus" class="text-sm opacity-80 flex items-center">
              <span class="status-indicator offline"></span> Offline
            </span>
          </div>
        </div>
        <button id="logoutBtn" class="bg-indigo-700 hover:bg-indigo-800 text-white py-1 px-3 rounded-full text-sm transition duration-300 ease-in-out">
          Logout
        </button>
      </div>

      <div class="p-4 border-b border-gray-200 flex items-center bg-gray-50">
        <input type="text" id="conversationSearch" placeholder="Search conversations..." class="flex-grow p-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200" />
        <button id="addChatBtn" class="ml-3 p-2 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-400 transition duration-300 ease-in-out" title="Start new chat">
          <i class="fas fa-plus"></i>
        </button>
      </div>

      <div id="userList" class="flex-1 overflow-y-auto p-2 bg-gray-50">
        <!-- User cards will be loaded here -->
        <div class="text-center text-gray-500 text-sm py-8">
          <i class="fas fa-spinner fa-spin text-xl mb-4"></i>
          <p>Loading conversations...</p>
        </div>
      </div>
    </aside>

    <!-- Right Chat Area -->
    <main class="flex-1 flex flex-col bg-gray-50">
      <!-- Chat Header -->
      <div id="chatHeader" class="p-4 bg-white border-b border-gray-200 flex items-center shadow-md rounded-tr-lg">
        <div class="w-10 h-10 rounded-full bg-gray-300 flex items-center justify-center text-lg font-bold mr-3 flex-shrink-0 text-gray-600">
          <i class="fas fa-user"></i>
        </div>
        <div class="flex flex-col flex-grow">
          <span id="selectedUserName" class="font-semibold text-xl text-gray-800">Select a user to chat</span>
          <span id="selectedUserStatus" class="text-sm text-gray-500 flex items-center">
            <span class="status-indicator offline"></span> Offline
            <span id="typingIndicator" class="ml-2 text-indigo-500 hidden text-xs italic">typing...</span>
          </span>
        </div>
      </div>

      <!-- Messages Container -->
      <div id="messagesContainer" class="flex-1 p-4 overflow-y-auto flex flex-col-reverse custom-scrollbar" style="max-height: calc(100vh - 120px);">
        <!-- Messages will be loaded here, using flex-col-reverse for scroll-to-bottom behavior -->
        <div class="text-center text-gray-500 text-sm py-8">
          <i class="fas fa-comments text-3xl mb-4"></i>
          <p>Start a conversation by selecting a user</p>
        </div>
      </div>

      <!-- Message Input -->
      <div class="p-4 bg-white border-t border-gray-200 shadow-inner">
        <form id="messageForm" class="flex items-center">
          <textarea id="messageInput" rows="1" placeholder="Type your message..." class="flex-grow p-3 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none transition duration-200 mr-3 custom-scrollbar"></textarea>
          <button type="submit" id="sendBtn" class="bg-indigo-500 text-white p-3 rounded-full shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-400 transition duration-300 ease-in-out">
            <i class="fas fa-paper-plane"></i>
          </button>
        </form>
      </div>
    </main>
  </div>

  <!-- Set Username Modal -->
  <div id="setUsernameModal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden modal-overlay">
    <div class="bg-white p-6 rounded-lg shadow-xl w-96 modal-content">
      <h2 class="text-2xl font-semibold mb-4 text-gray-800">Set Your Username</h2>
      <p class="text-gray-600 mb-6">Choose a unique username that will be visible to other users.</p>
      <input type="text" id="usernameInput" placeholder="Enter your username" class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-indigo-500" required>
      <button id="saveUsernameBtn" class="w-full bg-indigo-600 text-white py-3 rounded-lg hover:bg-indigo-700 transition duration-300 ease-in-out font-semibold">Save Username</button>
      <p id="usernameError" class="text-red-500 text-sm mt-2 hidden"></p>
    </div>
  </div>

  <!-- New Chat Modal -->
  <div id="newChatModal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden modal-overlay">
    <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 max-w-md modal-content">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-2xl font-semibold text-gray-800">Start New Chat</h2>
        <button id="closeNewChatModalBtn" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
      </div>
      <input type="text" id="allUserSearch" placeholder="Search users..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-indigo-500">
      <div id="allUserList" class="max-h-80 overflow-y-auto custom-scrollbar border border-gray-200 rounded-lg p-2">
        <!-- All available users will be loaded here -->
        <div class="text-center text-gray-500 text-sm py-8">
          <i class="fas fa-search text-xl mb-4"></i>
          <p>Search for users to start a chat.</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Supabase configuration
    const supabaseUrl = 'https://vmronlbzksuiikspvlvz.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZtcm9ubGJ6a3N1aWlrc3B2bHZ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk5ODMwNTcsImV4cCI6MjA2NTU1OTA1N30.WMKbpJn1aavkwQDmsYq_-4EMSLL9tc4LexpmRSCsmSM';
    const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

    // Global state
    let currentUser = null;
    let selectedUser = null;
    let usernameSet = false; // Flag to check if username is set
    let conversationUsers = []; // Users in the sidebar with active conversations
    let allAvailableUsers = []; // All users available for new chats
    let realtimeSubscription = null; // For real-time updates
    let typingTimeout = null; // For typing indicator
    let currentAuthListener = null; // To manage auth state listener cleanup

    // DOM Elements
    const userAvatar = document.getElementById('userAvatar');
    const userNameElement = document.getElementById('userName');
    const userStatusElement = document.getElementById('userStatus');
    const logoutBtn = document.getElementById('logoutBtn');
    const conversationSearch = document.getElementById('conversationSearch');
    const addChatBtn = document.getElementById('addChatBtn');
    const userListContainer = document.getElementById('userList');
    const chatHeader = document.getElementById('chatHeader');
    const selectedUserNameElement = document.getElementById('selectedUserName');
    const selectedUserStatusElement = document.getElementById('selectedUserStatus');
    const typingIndicator = document.getElementById('typingIndicator');
    const messagesContainer = document.getElementById('messagesContainer');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const messageForm = document.getElementById('messageForm'); // Get the form element

    // Modals
    const setUsernameModal = document.getElementById('setUsernameModal');
    const usernameInput = document.getElementById('usernameInput');
    const saveUsernameBtn = document.getElementById('saveUsernameBtn');
    const usernameError = document.getElementById('usernameError');

    const newChatModal = document.getElementById('newChatModal');
    const closeNewChatModalBtn = document.getElementById('closeNewChatModalBtn');
    const allUserSearch = document.getElementById('allUserSearch');
    const allUserListContainer = document.getElementById('allUserList');

    // Initialize the application
    async function initApp() {
      // Clear any existing auth listener to prevent duplicates on hot reload or re-init
      if (currentAuthListener) {
        currentAuthListener.unsubscribe();
      }

      currentAuthListener = supabase.auth.onAuthStateChange(async (event, session) => {
        if (event === 'SIGNED_IN' && session) {
          currentUser = session.user;
          console.log('User signed in:', currentUser);

          // Update user avatar
          const firstLetter = currentUser.email ? currentUser.email.charAt(0).toUpperCase() : 'U';
          userAvatar.textContent = firstLetter;

          await checkUsername(); // Check if username is set
          setupRealtimeSubscriptions(); // Set up real-time subscriptions
          updateUserStatus(true); // Set user status to online
          setupEventListeners(); // Set up event listeners
          await loadConversationUsers(); // Load initial conversations
        } else if (event === 'SIGNED_OUT') {
          console.log('User signed out.');
          currentUser = null;
          // Clear UI and redirect if needed
          userAvatar.textContent = 'U';
          userNameElement.textContent = 'Guest';
          userStatusElement.innerHTML = '<span class="status-indicator offline"></span> Offline';
          userListContainer.innerHTML = '';
          messagesContainer.innerHTML = '';
          selectedUserNameElement.textContent = 'Select a user to chat';
          selectedUserStatusElement.innerHTML = '<span class="status-indicator offline"></span> Offline';
          if (realtimeSubscription) {
            supabase.removeChannel(realtimeSubscription);
            realtimeSubscription = null;
          }
          window.location.href = 'index.html'; // Redirect to login page
        } else if (!session) {
          // If no session on initial load or after other auth events without a session
          window.location.href = 'index.html';
        }
      });

      // Initially check if there's a session on page load
      const { data: { session }, error } = await supabase.auth.getSession();
      if (error) {
        console.error("Error getting session:", error);
        // Do not redirect here, onAuthStateChange will handle it if no session.
      } else if (!session) {
         // If no session immediately, redirect to login to ensure user is authenticated
         // This handles cases where onAuthStateChange might fire later or not at all for initial unauthenticated state.
         window.location.href = 'index.html';
      }
    }

    // Check if username is set and prompt if not
    async function checkUsername() {
      if (!currentUser) return;

      const { data, error } = await supabase
        .from('profiles')
        .select('username')
        .eq('id', currentUser.id)
        .single();

      if (error || !data || !data.username) {
        usernameSet = false;
        setUsernameModal.classList.remove('hidden');
        userNameElement.textContent = 'Set Username';
        userStatusElement.innerHTML = '<span class="status-indicator offline"></span> Not Set';
      } else {
        usernameSet = true;
        currentUser.username = data.username; // Attach username to currentUser object
        userNameElement.textContent = data.username;
        setUsernameModal.classList.add('hidden'); // Hide modal if username is set
        console.log("Username set for current user:", data.username);
      }
    }

    // Set username
    async function setUsername() {
      const newUsername = usernameInput.value.trim();
      if (!newUsername) {
        usernameError.textContent = 'Username cannot be empty.';
        usernameError.classList.remove('hidden');
        return;
      }
      usernameError.classList.add('hidden');

      try {
        // Check if username already exists
        const { data: existingUser, error: existingError } = await supabase
          .from('profiles')
          .select('id')
          .eq('username', newUsername)
          .maybeSingle();

        if (existingError) throw existingError;

        if (existingUser && existingUser.id !== currentUser.id) {
          usernameError.textContent = 'This username is already taken. Please choose another.';
          usernameError.classList.remove('hidden');
          return;
        }

        // Update or insert username
        const { error: upsertError } = await supabase
          .from('profiles')
          .upsert({ id: currentUser.id, username: newUsername }, { onConflict: 'id' });

        if (upsertError) throw upsertError;

        usernameSet = true;
        currentUser.username = newUsername;
        userNameElement.textContent = newUsername;
        setUsernameModal.classList.add('hidden');
        updateUserStatus(true); // Ensure status is updated after setting username
        await loadConversationUsers(); // Load conversations after username is confirmed
        alert('Username saved successfully!');

      } catch (error) {
        console.error('Error setting username:', error);
        usernameError.textContent = `Failed to set username: ${error.message}`;
        usernameError.classList.remove('hidden');
      }
    }

    // Set up real-time subscriptions
    function setupRealtimeSubscriptions() {
      if (!currentUser) return;

      // Unsubscribe from any existing subscriptions before creating new ones
      if (realtimeSubscription) {
        supabase.removeChannel(realtimeSubscription);
      }

      console.log('Setting up real-time subscriptions for user:', currentUser.id);

      // Subscribe to new messages for this user (received)
      const messagesChannel = supabase
        .channel('messages_channel')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'messages',
            filter: `receiver_id=eq.${currentUser.id}`
          },
          (payload) => {
            console.log('New message received payload:', payload.new);
            // If the message is from the currently selected user, add to UI
            if (selectedUser && payload.new.sender_id === selectedUser.id) {
              addMessageToUI(payload.new);
              scrollToBottom();
            }
            // Update conversation list for unread counts/ordering
            loadConversationUsers(); // Re-loads and re-renders to ensure list is up-to-date and ordered correctly.
          }
        )
        // Subscribe to new messages sent by this user
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'messages',
            filter: `sender_id=eq.${currentUser.id}`
          },
          (payload) => {
            console.log('New message sent payload:', payload.new);
            // This message was sent by current user, already added to UI by sendMessage function
            // We can use this to confirm it was saved or for further actions if needed.
            // No need to add to UI again here to prevent duplicates
            
            // Ensure the recipient is in the conversation list
            const recipientId = payload.new.receiver_id;
            const recipientExists = conversationUsers.some(u => u.id === recipientId);
            if (!recipientExists) {
                // Fetch the recipient's profile and add to conversationUsers
                fetchUserAndAddToConversation(recipientId);
            } else {
                // Just refresh conversation list to reorder if needed
                loadConversationUsers();
            }
          }
        )
        // Subscribe to profile updates (for status changes)
        .on(
          'postgres_changes',
          {
            event: 'UPDATE',
            schema: 'public',
            table: 'profiles'
          },
          (payload) => {
            const updatedProfile = payload.new;
            console.log('Profile updated:', updatedProfile);
            updateUserStatusUI(updatedProfile);
            if (updatedProfile.id === selectedUser?.id) {
              // Update selected user's status in header
              selectedUserStatusElement.innerHTML = `<span class="status-indicator ${updatedProfile.status === 'online' ? 'online' : 'offline'}"></span> ${updatedProfile.status || 'offline'}`;
              // Handle typing indicator logic based on status or separate typing event
              if (updatedProfile.is_typing && updatedProfile.id === selectedUser.id && updatedProfile.status === 'online') {
                  typingIndicator.classList.remove('hidden');
              } else {
                  typingIndicator.classList.add('hidden');
              }
            }
            // Also refresh the conversation list to update statuses in the sidebar
            loadConversationUsers(); // This will re-render users with updated statuses
          }
        )
        .subscribe();

      realtimeSubscription = messagesChannel; // Store the channel reference
    }

    // Helper to fetch a user and add to conversation list if not present
    async function fetchUserAndAddToConversation(userId) {
        const { data: user, error } = await supabase
            .from('profiles')
            .select('id, username, status')
            .eq('id', userId)
            .single();

        if (error) {
            console.error('Error fetching user for conversation list:', error);
            return;
        }

        if (user && !conversationUsers.some(u => u.id === user.id)) {
            conversationUsers.push(user);
            renderUsers(conversationUsers, userListContainer, selectUser);
        }
    }

    // Update user status in UI
    function updateUserStatusUI(user) {
      // Update status in the sidebar's user list
      const userCards = userListContainer.querySelectorAll('.user-card');
      userCards.forEach(card => {
        const userId = card.getAttribute('data-user-id');
        if (userId === user.id) {
          const statusIndicator = card.querySelector('.status-indicator');
          const statusText = card.querySelector('.status-text');
          if (statusIndicator) {
            statusIndicator.className = `status-indicator ${user.status === 'online' ? 'online' : 'offline'}`;
          }
          if (statusText) {
            statusText.textContent = user.status || 'offline';
          }
        }
      });
    }

    // Load messages between current user and selected user
    async function loadMessages() {
      messagesContainer.innerHTML = ''; // Clear current messages

      if (!selectedUser) {
        messagesContainer.innerHTML = `
          <div class="text-center text-gray-500 text-sm py-8">
            <i class="fas fa-comments text-3xl mb-4"></i>
            <p>Start a conversation by selecting a user</p>
          </div>
        `;
        return;
      }

      messagesContainer.innerHTML = `
        <div class="text-center text-gray-500 text-sm py-8">
          <i class="fas fa-spinner fa-spin text-xl mb-4"></i>
          <p>Loading messages...</p>
        </div>
      `;

      try {
        const { data: messages, error } = await supabase
          .from('messages')
          .select('*')
          .or(`and(sender_id.eq.${currentUser.id},receiver_id.eq.${selectedUser.id}),and(sender_id.eq.${selectedUser.id},receiver_id.eq.${currentUser.id})`)
          .order('created_at', { ascending: true });

        if (error) throw error;

        messagesContainer.innerHTML = ''; // Clear loading indicator

        if (!messages || messages.length === 0) {
          messagesContainer.innerHTML = `
            <div class="text-center text-gray-500 text-sm py-8">
              <i class="fas fa-comment-slash text-3xl mb-4"></i>
              <p>No messages yet. Say hello!</p>
            </div>
          `;
          return;
        }

        messages.forEach(message => {
          addMessageToUI(message);
        });

        scrollToBottom();

      } catch (error) {
        console.error('Load messages error:', error);
        messagesContainer.innerHTML = `
          <div class="text-center text-red-400 text-sm py-8">
            <i class="fas fa-exclamation-triangle text-3xl mb-4"></i>
            <p>Error loading messages. Please try again.</p>
          </div>
        `;
      }
    }

    // Add message to UI
    function addMessageToUI(message) {
      const isCurrentUser = message.sender_id === currentUser.id;

      // Check if a placeholder message (e.g., "No messages yet") exists and remove it
      if (messagesContainer.querySelector('.text-center')) {
        messagesContainer.innerHTML = '';
      }

      const messageElement = document.createElement('div');
      messageElement.className = `message-bubble ${isCurrentUser ? 'sent' : 'received'} flex flex-col`;

      messageElement.innerHTML = `
        <div class="message-text">${message.content}</div>
        <div class="message-time text-xs opacity-70 mt-1 ${isCurrentUser ? 'self-end' : 'self-start'}">${formatTime(message.created_at)}</div>
      `;

      // Use `prepend` instead of `appendChild` if messagesContainer is flex-col-reverse
      // This ensures new messages appear at the bottom while maintaining scroll behavior
      messagesContainer.prepend(messageElement);
    }

    // Scroll to the bottom of the messages container
    function scrollToBottom() {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // Format time for display
    function formatTime(dateString) {
      try {
        const date = new Date(dateString);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch {
        return 'Invalid Date';
      }
    }

    // Send message
    async function sendMessage(event) {
      event.preventDefault(); // Prevent default form submission and page refresh

      const content = messageInput.value.trim();
      if (!content || !selectedUser || !currentUser) return;

      // Clear input immediately
      messageInput.value = '';
      messageInput.style.height = 'auto'; // Reset textarea height

      // Immediately add the message to the UI (optimistic update)
      const tempMessage = {
        sender_id: currentUser.id,
        receiver_id: selectedUser.id,
        content: content,
        created_at: new Date().toISOString() // Use current time for optimistic display
      };
      addMessageToUI(tempMessage);
      scrollToBottom();

      try {
        // Insert message to database
        const { error } = await supabase
          .from('messages')
          .insert({
            sender_id: currentUser.id,
            receiver_id: selectedUser.id,
            content: content
          });

        if (error) throw error;
        
        // After successful send, ensure recipient is in conversation list and update its order
        await loadConversationUsers(); // Re-load and re-render conversations to reflect new message order
        
      } catch (error) {
        console.error('Send message error:', error);
        // Optionally, remove the optimistically added message or show an error
        alert('Failed to send message. Please check your connection.');
      } finally {
        // Reset typing status after sending message
        updateTypingStatus(false);
      }
    }

    // Typing indicator status update
    async function updateTypingStatus(isTyping) {
        if (!currentUser || !selectedUser) return;
        try {
            await supabase
                .from('profiles')
                .update({ is_typing: isTyping, typing_to: isTyping ? selectedUser.id : null })
                .eq('id', currentUser.id);
        } catch (error) {
            console.error('Error updating typing status:', error);
        }
    }

    function handleTyping() {
      // Show typing indicator in UI if the selected user is typing to *us*
      // This part is handled by the `profiles` real-time subscription for `is_typing` and `typing_to`

      // And send *our* typing status to Supabase
      updateTypingStatus(true); // Tell others we are typing

      // Clear any existing timeout for stopping typing status
      if (typingTimeout) clearTimeout(typingTimeout);
      
      // Set new timeout to stop typing status after a delay
      typingTimeout = setTimeout(() => {
        updateTypingStatus(false); // Tell others we stopped typing
      }, 2000); // Stop typing after 2 seconds of inactivity
    }

    // Auto-resize message input textarea
    function autoResizeTextarea() {
        messageInput.style.height = 'auto';
        messageInput.style.height = messageInput.scrollHeight + 'px';
    }


    // Update user status (online/offline)
    async function updateUserStatus(isOnline) {
      if (!currentUser) return;
      try {
        const status = isOnline ? 'online' : 'offline';
        userStatusElement.innerHTML = `<span class="status-indicator ${status}"></span> ${status}`;
        
        const { error } = await supabase
          .from('profiles')
          .update({ status: status })
          .eq('id', currentUser.id);

        if (error) throw error;

      } catch (error) {
        console.error('Update status error:', error);
      }
    }

    // Select a user from the sidebar
    async function selectUser(user) {
      if (selectedUser && selectedUser.id === user.id) {
        // User already selected, do nothing
        return;
      }
      
      // Deselect previously selected user card visually
      if (selectedUser) {
        const prevSelectedCard = document.querySelector(`.user-card[data-user-id="${selectedUser.id}"]`);
        if (prevSelectedCard) {
          prevSelectedCard.classList.remove('bg-indigo-100', 'border-indigo-500');
        }
      }

      selectedUser = user;
      
      // Update chat header with selected user's info
      selectedUserNameElement.textContent = user.username;
      selectedUserStatusElement.innerHTML = `<span class="status-indicator ${user.status === 'online' ? 'online' : 'offline'}"></span> ${user.status || 'offline'}`;
      typingIndicator.classList.add('hidden'); // Hide typing indicator initially

      // Visually mark the selected user card
      const selectedUserCard = document.querySelector(`.user-card[data-user-id="${user.id}"]`);
      if (selectedUserCard) {
        selectedUserCard.classList.add('bg-indigo-100', 'border-indigo-500');
      }

      // Load messages for the selected conversation
      await loadMessages();
      scrollToBottom();
      messageInput.focus(); // Focus on input field
    }

    // Render a list of users into a container
    function renderUsers(users, container, clickHandler) {
      container.innerHTML = ''; // Clear previous users
      if (users.length === 0) {
        container.innerHTML = `
          <div class="text-center text-gray-500 text-sm py-8">
            <i class="fas fa-users text-xl mb-4"></i>
            <p>${container === userListContainer ? 'No active conversations.' : 'No users found.'}</p>
          </div>
        `;
        return;
      }

      users.forEach(user => {
        if (user.id === currentUser.id) return; // Don't show current user in list

        const userCard = document.createElement('div');
        userCard.className = `user-card flex items-center p-3 my-1 rounded-lg hover:bg-gray-100 cursor-pointer transition duration-200 border border-transparent ${selectedUser?.id === user.id ? 'bg-indigo-100 border-indigo-500' : ''}`;
        userCard.setAttribute('data-user-id', user.id);
        userCard.innerHTML = `
          <div class="w-10 h-10 rounded-full bg-gray-300 flex items-center justify-center text-base font-bold mr-3 flex-shrink-0 text-gray-600">
            ${user.username ? user.username.charAt(0).toUpperCase() : 'U'}
          </div>
          <div class="flex-grow">
            <h3 class="font-semibold text-gray-800">${user.username}</h3>
            <p class="text-sm text-gray-500 flex items-center">
              <span class="status-indicator ${user.status === 'online' ? 'online' : 'offline'}"></span>
              <span class="status-text">${user.status || 'offline'}</span>
            </p>
          </div>
          <!-- You can add unread message count here later -->
        `;
        userCard.addEventListener('click', () => clickHandler(user));
        container.appendChild(userCard);
      });
    }

    // Load active conversation users (those with whom current user has exchanged messages)
    async function loadConversationUsers() {
      userListContainer.innerHTML = `
        <div class="text-center text-gray-500 text-sm py-8">
          <i class="fas fa-spinner fa-spin text-xl mb-4"></i>
          <p>Loading conversations...</p>
        </div>
      `;
      try {
        // Fetch users who have sent messages to or received messages from the current user
        const { data: messages, error: messagesError } = await supabase
          .from('messages')
          .select('sender_id, receiver_id, created_at')
          .or(`sender_id.eq.${currentUser.id},receiver_id.eq.${currentUser.id}`)
          .order('created_at', { ascending: false }); // Get most recent messages first

        if (messagesError) throw messagesError;

        const participantIds = new Set();
        messages.forEach(msg => {
          if (msg.sender_id === currentUser.id) {
            participantIds.add(msg.receiver_id);
          } else if (msg.receiver_id === currentUser.id) {
            participantIds.add(msg.sender_id);
          }
        });

        // Fetch profiles for these participants
        const idsArray = Array.from(participantIds);
        if (idsArray.length === 0) {
          conversationUsers = [];
          renderUsers([], userListContainer, selectUser); // Render empty list
          return;
        }

        const { data: profiles, error: profilesError } = await supabase
          .from('profiles')
          .select('id, username, status')
          .in('id', idsArray);

        if (profilesError) throw profilesError;

        // Sort profiles based on the last message time if needed (more complex logic for last message summary)
        // For now, just render them, they are effectively sorted by who we've recently communicated with due to Set.
        conversationUsers = profiles.filter(p => p.id !== currentUser.id); // Filter out current user from their own list
        renderUsers(conversationUsers, userListContainer, selectUser);

      } catch (error) {
        console.error('Error loading conversation users:', error);
        userListContainer.innerHTML = `
          <div class="text-center text-red-400 text-sm py-8">
            <i class="fas fa-exclamation-triangle text-3xl mb-4"></i>
            <p>Error loading conversations.</p>
          </div>
        `;
      }
    }

    // Filter conversation users in the sidebar
    function filterConversationUsers(searchTerm) {
      const filtered = conversationUsers.filter(user =>
        user.username.toLowerCase().includes(searchTerm.toLowerCase())
      );
      renderUsers(filtered, userListContainer, selectUser);
    }

    // Open New Chat Modal
    async function openNewChatModal() {
      newChatModal.classList.remove('hidden');
      await loadAllAvailableUsers();
    }

    // Close New Chat Modal
    function closeNewChatModal() {
      newChatModal.classList.add('hidden');
      allUserSearch.value = ''; // Clear search
      allUserListContainer.innerHTML = ''; // Clear list
    }

    // Load all available users for new chat modal
    async function loadAllAvailableUsers() {
      allUserListContainer.innerHTML = `
        <div class="text-center text-gray-500 text-sm py-8">
          <i class="fas fa-spinner fa-spin text-xl mb-4"></i>
          <p>Loading all users...</p>
        </div>
      `;
      try {
        const { data: users, error } = await supabase
          .from('profiles')
          .select('id, username, status')
          .neq('id', currentUser.id) // Exclude current user
          .order('username', { ascending: true }); // Order alphabetically

        if (error) throw error;

        allAvailableUsers = users || [];
        renderUsers(allAvailableUsers, allUserListContainer, (user) => {
          selectUser(user);
          closeNewChatModal(); // Close modal after selecting user
        });

      } catch (error) {
        console.error('Error loading all available users:', error);
        allUserListContainer.innerHTML = `
          <div class="text-center text-red-400 text-sm py-8">
            <i class="fas fa-exclamation-triangle text-3xl mb-4"></i>
            <p>Error loading users.</p>
          </div>
        `;
      }
    }

    // Filter all users in the New Chat modal
    function filterAllUsers(searchTerm) {
      const filtered = allAvailableUsers.filter(user =>
        user.username.toLowerCase().includes(searchTerm.toLowerCase())
      );
      renderUsers(filtered, allUserListContainer, (user) => {
        selectUser(user);
        closeNewChatModal();
      });
    }

    // Set up event listeners
    function setupEventListeners() {
      // Prevent multiple listeners if initApp runs again
      messageForm.removeEventListener('submit', sendMessage);
      messageInput.removeEventListener('input', autoResizeTextarea);
      messageInput.removeEventListener('input', handleTyping);
      logoutBtn.removeEventListener('click', handleLogout);
      conversationSearch.removeEventListener('input', handleConversationSearch);
      addChatBtn.removeEventListener('click', openNewChatModal);
      closeNewChatModalBtn.removeEventListener('click', closeNewChatModal);
      allUserSearch.removeEventListener('input', handleAllUserSearch);
      saveUsernameBtn.removeEventListener('click', setUsername);

      // Add new listeners
      messageForm.addEventListener('submit', sendMessage); // Handle form submission
      messageInput.addEventListener('input', autoResizeTextarea); // Auto-resize textarea
      messageInput.addEventListener('input', handleTyping); // Typing indicator
      
      logoutBtn.addEventListener('click', handleLogout);
      conversationSearch.addEventListener('input', handleConversationSearch);
      addChatBtn.addEventListener('click', openNewChatModal);
      closeNewChatModalBtn.addEventListener('click', closeNewChatModal);
      allUserSearch.addEventListener('input', handleAllUserSearch);
      saveUsernameBtn.addEventListener('click', setUsername);

      // Event listeners for window focus/blur
      window.removeEventListener('focus', handleWindowFocus);
      window.removeEventListener('blur', handleWindowBlur);
      window.addEventListener('focus', handleWindowFocus);
      window.addEventListener('blur', handleWindowBlur);

      // Event listener for beforeunload
      window.removeEventListener('beforeunload', handleBeforeUnload);
      window.addEventListener('beforeunload', handleBeforeUnload);
    }

    // Event handler wrappers to manage potential re-assignment issues
    function handleLogout() {
        if (!currentUser) return; // Ensure currentUser is available before attempting logout
        try {
            updateUserStatus(false);
            supabase.auth.signOut();
            // Redirect will be handled by onAuthStateChange listener
        } catch (error) {
            console.error('Logout error:', error);
            alert('Logout failed. Please try again.');
        }
    }

    function handleConversationSearch(e) {
        filterConversationUsers(e.target.value.trim());
    }

    function handleAllUserSearch(e) {
        filterAllUsers(e.target.value.trim());
    }

    function handleWindowFocus() {
        updateUserStatus(true);
    }

    function handleWindowBlur() {
        updateUserStatus(false);
    }

    async function handleBeforeUnload() {
        await updateUserStatus(false); // Set offline before navigating away
        if (realtimeSubscription) {
            supabase.removeChannel(realtimeSubscription);
            realtimeSubscription = null;
        }
        // No need to prevent default or return anything specific unless you want a browser prompt
    }

    // Initialize the app on DOM content loaded
    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>

