<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TAKA AI</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="avatar.png" />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font Awesome for icons (dark mode toggle, copy, delete) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" xintegrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <!-- Marked.js for Markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* Basic styling for smooth scrolling and font rendering */
    * {
      scroll-behavior: smooth;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      font-family: 'Inter', sans-serif; /* Using Inter font */
    }
    /* Apply Inter font */
    body {
        font-family: 'Inter', sans-serif;
    }
    /* Container for chat bubbles to manage layout */
    .bubble-container {
      display: flex;
      gap: 8px;
      margin-bottom: 10px; /* Increased margin for better spacing */
      align-items: flex-start;
      position: relative; /* For copy button positioning */
    }
    /* Common bubble styling */
    .bubble {
      max-width: 90%;
      padding: 12px 18px; /* Slightly larger padding */
      border-radius: 1.25rem; /* More rounded corners */
      white-space: pre-wrap; /* Preserve whitespace and line breaks */
      word-wrap: break-word; /* Allow long words to break */
      will-change: transform, opacity; /* Optimize animations */
      backface-visibility: hidden; /* Prevent flickering */
      box-shadow: 0 1px 3px rgba(0,0,0,0.08); /* Subtle shadow */
    }
    /* User specific bubble styling */
    .user-bubble {
      background-color: #2563eb; /* Blue background */
      color: white;
      margin-left: auto; /* Push to the right */
      border-bottom-right-radius: 0.5rem; /* Smaller radius on the 'tail' side */
    }
    /* Bot specific bubble styling */
    .bot-bubble {
      background-color: #f3f4f6; /* Light gray background */
      color: black;
      border-bottom-left-radius: 0.5rem; /* Smaller radius on the 'tail' side */
    }
    /* Styling for typing indicator */
    .typing {
      font-style: italic;
      color: #9ca3af;
      padding: 10px 15px; /* Match bubble padding */
    }
    /* Animation for the typing indicator dots */
    @keyframes dots {
      0% { content: ''; }
      33% { content: '.'; }
      66% { content: '..'; }
      100% { content: '...'; }
    }
    /* Apply dot animation to the thinking message */
    #thinking::after {
      content: '.';
      animation: dots 1s steps(3, end) infinite;
    }
    /* Styling for mode selection dropdown */
    .mode-select {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px); /* Frosted glass effect */
      border: 1px solid rgba(255,255,255,0.2); /* Light border */
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    /* Optimize chatbox rendering */
    #chatbox {
      transform: translateZ(0); /* Force hardware acceleration */
      overflow-anchor: none; /* Prevent scroll jumps */
      border: none; /* Remove default border */
    }
    /* Avatar styling */
    .avatar {
      width: 35px; /* Slightly larger avatar */
      height: 35px;
      border-radius: 50%;
      object-fit: cover;
      margin-top: 5px;
      flex-shrink: 0; /* Prevent shrinking */
    }
    /* Sidebar styling for desktop and mobile */
    .sidebar {
      width: 260px;
      height: 100vh;
      position: fixed;
      left: 0;
      top: 0;
      background: #1e1e2d; /* Dark background */
      border-right: 1px solid #2d3748; /* Border to separate from main content */
      transition: transform 0.3s ease; /* Smooth transition for opening/closing */
      z-index: 40; /* Ensure it's above other content */
      overflow-y: auto; /* Enable vertical scrolling */
      color: white;
      box-shadow: 2px 0 5px rgba(0,0,0,0.2); /* Shadow for depth */
    }
    .sidebar-header {
      padding: 1rem;
      border-bottom: 1px solid #2d3748;
      display: flex;
      justify-content: space-between; /* Space for mode toggle in sidebar */
      align-items: center;
    }
    /* Styling for individual chat items in history */
    .chat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      cursor: pointer;
      border-bottom: 1px solid #2d3748;
      white-space: nowrap; /* Prevent title from wrapping */
      overflow: hidden; /* Hide overflowed text */
      text-overflow: ellipsis; /* Show ellipsis for truncated text */
      color: white;
      transition: background-color 0.2s ease;
    }
    .chat-item:hover {
      background: #2d3748; /* Highlight on hover */
    }
    .chat-item.active {
      background: #4a5568; /* Active chat highlight */
      font-weight: bold;
    }
    /* Delete button within chat item */
    .chat-item .delete-chat-btn {
      background: none;
      border: none;
      color: #ccc;
      font-size: 0.9rem;
      cursor: pointer;
      margin-left: 10px;
      opacity: 0; /* Hidden by default */
      transition: opacity 0.2s ease, color 0.2s ease;
    }
    .chat-item:hover .delete-chat-btn, .chat-item.active .delete-chat-btn {
      opacity: 1; /* Show on hover or when active */
    }
    .chat-item .delete-chat-btn:hover {
      color: #ff4a4a; /* Red on hover */
    }
    /* Styling for the "New Chat" button */
    .new-chat-btn {
      width: 100%;
      padding: 0.75rem 1rem;
      margin: 0.5rem 0;
      border: 1px dashed #4a5568; /* Dashed border */
      border-radius: 0.5rem; /* More rounded */
      cursor: pointer;
      text-align: center;
      color: white;
      background: rgba(255, 255, 255, 0.05); /* Slightly transparent background */
      transition: background-color 0.2s ease;
    }
    .new-chat-btn:hover {
      background: rgba(255, 255, 255, 0.1); /* Darker on hover */
    }
    /* Main content area */
    .main-content {
      margin-left: 260px; /* Offset by sidebar width */
      transition: margin-left 0.3s ease; /* Smooth transition */
      display: flex;
      flex-direction: column;
      height: 100vh; /* Full height */
      padding-bottom: 1rem; /* Padding for input area */
    }
    /* Sidebar toggle button (mobile only) */
    .sidebar-toggle {
      position: fixed;
      left: 1rem;
      top: 1rem;
      z-index: 50;
      background: #1e1e2d;
      border-radius: 50%;
      padding: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      cursor: pointer;
      display: none; /* Hidden by default on desktop */
      color: white; /* Icon color */
      transition: transform 0.2s ease;
    }
    .sidebar-toggle:active {
        transform: scale(0.95);
    }

    /* Dark Mode Toggle Button */
    .dark-mode-toggle {
        background: none;
        border: none;
        color: white;
        font-size: 1.2rem;
        cursor: pointer;
        transition: color 0.2s ease;
    }
    .dark-mode-toggle:hover {
        color: #a0aec0; /* Lighter on hover */
    }

    /* Input container styling */
    .input-container {
        display: flex;
        align-items: center;
        background: linear-gradient(to right, #ffffff, #f0f0f0); /* Subtle gradient */
        border-radius: 0.75rem; /* Rounded corners */
        box-shadow: 0 4px 10px rgba(0,0,0,0.1); /* More prominent shadow */
        padding: 0.5rem;
        border: 1px solid #e2e8f0; /* Light border */
    }
    .dark .input-container {
        background: linear-gradient(to right, #2d3748, #1a202c);
        border: 1px solid #4a5568;
    }
    #userInput {
        background: transparent;
        border: none;
        outline: none;
        padding: 0.5rem 1rem;
        flex-grow: 1;
        color: inherit; /* Inherit text color from body */
    }
    #userInput::placeholder {
        color: #a0aec0; /* Placeholder color */
    }
    .dark #userInput::placeholder {
        color: #718096;
    }
    #sendButton {
        background: linear-gradient(to right, #2563eb, #3b82f6); /* Blue gradient */
        border: none;
        padding: 0.75rem 1.5rem; /* Larger padding */
        border-radius: 0.625rem; /* Rounded button */
        font-weight: 600; /* Semi-bold */
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }
    #sendButton:hover {
        transform: translateY(-1px); /* Slight lift on hover */
        box-shadow: 0 4px 8px rgba(0,0,0,0.25);
    }
    #sendButton:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    #sendButton:disabled {
        background: #9ca3af;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
    }

    /* Copy to clipboard button styling */
    .copy-btn {
        background: rgba(0,0,0,0.05); /* Slightly transparent background */
        border: none;
        border-radius: 0.375rem; /* Rounded */
        padding: 0.3rem 0.6rem;
        font-size: 0.8rem;
        cursor: pointer;
        margin-left: 10px; /* Space from text */
        color: #4a5568;
        transition: background-color 0.2s ease, color 0.2s ease;
        opacity: 0; /* Hidden by default */
        position: absolute;
        top: 0;
        right: 0; /* Position top right within bubble-container */
        transform: translateX(calc(100% + 5px)); /* Offset to the right */
    }
    .bot-bubble + .copy-btn { /* Select copy button adjacent to bot bubble */
        transform: translateX(calc(100% + 5px)); /* Offset to the right */
    }

    .bubble-container:hover .copy-btn {
        opacity: 1; /* Show on hover of the container */
    }
    .copy-btn:hover {
        background: #e2e8f0;
        color: #2d3748;
    }
    .dark .copy-btn {
        background: rgba(255,255,255,0.1);
        color: #cbd5e0;
    }
    .dark .copy-btn:hover {
        background: rgba(255,255,255,0.2);
        color: white;
    }

    /* Scroll to bottom button */
    #scrollToBottomBtn {
        position: fixed;
        bottom: 100px; /* Above input field */
        right: 1rem;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        cursor: pointer;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.2s ease;
        z-index: 30;
    }
    #scrollToBottomBtn.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
    }
    #scrollToBottomBtn:hover {
        transform: translateY(-2px);
    }

    /* Markdown styling within bubbles */
    .bubble pre {
        background-color: rgba(0,0,0,0.05);
        padding: 10px;
        border-radius: 0.5rem;
        overflow-x: auto;
        margin-top: 10px;
        font-family: monospace;
        font-size: 0.9em;
    }
    .dark .bubble pre {
        background-color: rgba(255,255,255,0.1);
    }
    .bubble code {
        background-color: rgba(0,0,0,0.08);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: monospace;
    }
    .dark .bubble code {
        background-color: rgba(255,255,255,0.15);
    }
    .bubble a {
        color: #2563eb;
        text-decoration: underline;
    }
    .dark .bubble a {
        color: #93c5fd;
    }
    .bubble ul, .bubble ol {
        margin-left: 20px;
        margin-top: 10px;
    }
    .bubble li {
        margin-bottom: 5px;
    }

    /* Responsive adjustments for mobile */
    @media (max-width: 768px) {
      .sidebar {
        transform: translateX(-100%); /* Hide sidebar by default on mobile */
      }
      .sidebar.open {
        transform: translateX(0); /* Show sidebar when open */
      }
      .main-content {
        margin-left: 0; /* No offset on mobile */
        padding-top: 60px; /* Adjust padding for toggle button */
        padding-bottom: 1rem;
      }
      .sidebar-toggle {
        display: block; /* Show toggle button on mobile */
      }
      .mode-select {
          width: 120px; /* Smaller mode select on mobile */
          font-size: 0.75rem;
      }
      .sidebar-header {
          flex-direction: column; /* Stack header elements */
          align-items: flex-start;
      }
      .dark-mode-toggle {
          margin-top: 0.5rem;
          align-self: flex-end; /* Push toggle to right */
      }
      #scrollToBottomBtn {
          bottom: 80px; /* Adjust for smaller screens */
          right: 0.5rem;
      }
    }
  </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen transition-colors duration-300">
  <!-- Sidebar Toggle Button (visible on mobile) -->
  <div class="sidebar-toggle" id="sidebarToggle">
    <i class="fas fa-bars"></i> <!-- Font Awesome Bars icon -->
  </div>

  <!-- Sidebar for chat history and new chat button -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
        <button class="new-chat-btn" id="newChatBtn">
            <i class="fas fa-plus"></i> New Chat
        </button>
        <!-- Dark Mode Toggle Button in Sidebar Header for mobile visibility -->
        <button id="darkModeToggle" class="dark-mode-toggle">
            <i class="fas fa-moon"></i> <!-- Moon icon for dark mode -->
        </button>
    </div>
    <div id="chatHistory"></div>
  </div>

  <!-- Main Content Area -->
  <div class="main-content max-w-3xl mx-auto p-4 flex flex-col">
    <div class="flex justify-between items-center mb-2">
      <div class="flex items-center gap-3">
        <img src="avatar.png" class="w-10 h-10 rounded-full" loading="eager" alt="TAKA AI Avatar"/>
        <h1 class="text-2xl font-bold">TAKA AI</h1>
      </div>
      <div class="flex items-center gap-2">
        <!-- Dropdown for selecting AI mode -->
        <select id="mode" class="mode-select rounded px-3 py-1 text-sm dark:bg-gray-800 dark:text-white"></select>
        <!-- Dark Mode Toggle Button (Desktop Only) -->
        <button id="darkModeToggleDesktop" class="dark-mode-toggle hidden md:block">
            <i class="fas fa-moon"></i> <!-- Moon icon for dark mode -->
        </button>
      </div>
    </div>

    <!-- Description for the selected AI mode -->
    <div id="desc" class="text-sm italic mb-2 text-gray-700 dark:text-gray-300"></div>

    <!-- Chat display area -->
    <div id="chatbox" class="flex-1 overflow-y-auto space-y-2 p-2 bg-white dark:bg-gray-800 rounded-lg shadow-inner"></div>

    <!-- Input field and send button container -->
    <div class="mt-4 input-container">
      <textarea id="userInput" placeholder="Ask something..."
        class="flex-1 px-4 py-2 resize-none"
        rows="1"
        autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
      <button id="sendButton" class="text-white px-4 py-2 rounded-r-lg">
        <i class="fas fa-paper-plane"></i> Send
      </button>
    </div>
  </div>

  <!-- Scroll to Bottom Button -->
  <button id="scrollToBottomBtn" class="hidden">
      <i class="fas fa-arrow-down"></i>
  </button>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

    // Initialize Supabase client for modes data
    const supabase = createClient(
      "https://vmronlbzksuiikspvlvz.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZtcm9ubGJ6a3N1aWlrc3B2bHZ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk5ODMwNTcsImV4cCI6MjA2NTU1OTA1N30.WMKbpJn1aavkwQDmsYq_-4EMSLL9tc4LexpmRSCsmSM",
      {
        realtime: {
          params: {
            eventsPerSecond: 10,
          }
        }
      }
    );

    // DOM Elements
    const modeSelect = document.getElementById("mode");
    const modeDescBox = document.getElementById("desc");
    const chatbox = document.getElementById("chatbox");
    const userInput = document.getElementById("userInput");
    const sendButton = document.getElementById("sendButton");
    const sidebar = document.getElementById("sidebar");
    const sidebarToggle = document.getElementById("sidebarToggle");
    const chatHistory = document.getElementById("chatHistory");
    const newChatBtn = document.getElementById("newChatBtn");
    const darkModeToggle = document.getElementById("darkModeToggle");
    const darkModeToggleDesktop = document.getElementById("darkModeToggleDesktop");
    const scrollToBottomBtn = document.getElementById("scrollToBottomBtn");

    // API Configuration for various AI models
    // Using multiple endpoints for potential fallback/load balancing
    const API_CONFIGS = [
      {
        endpoint: "https://llm.chutes.ai/v1/chat/completions",
        apiKey: "cpk_ae2395a5321940e6b3b24b4d51921ef2.2fe6509bc2a35be39e98a9a6f4b42a5b.h1vSu7eUd5g48HELY2GVXy9uObrOVGKK",
        model: "deepseek-ai/DeepSeek-V3-0324"
      },
      {
        endpoint: "https://llm.chutes.ai/v1/chat/completions",
        apiKey: "cpk_99378916287c495c9d1279af9b0a9063.2fe6509bc2a35be39e98a9a6f4b42a5b.UtrOZrL0d05xpb04QQuq4L0ouNbsLUF5",
        model: "deepseek-ai/DeepSeek-V3-0324"
      },
      {
        endpoint: "https://llm.chutes.ai/v1/chat/completions",
        apiKey: "cpk_25632a3253e04ffab45b2791f3316314.2fe6509bc2a35be39e98a9a6f4b42a5b.OEMDDYtbPBDLce1V4RbRD9RkagX61XU0",
        model: "deepseek-ai/DeepSeek-V3-0324"
      },
      {
        endpoint: "https://llm.chutes.ai/v1/chat/completions",
        apiKey: "cpk_cc62c97679bc4fda82032c03e391d40e.2fe6509bc2a35be39e98a9a6f4b42a5b.nvdRGo0TB6HUAoIHkY3UZtkycbRBhgzc",
        model: "deepseek-ai/DeepSeek-V3-0324"
      },
      {
        endpoint: "https://llm.chutes.ai/v1/chat/completions",
        apiKey: "cpk_7f6b157824be48e6a310985d940f5cb8.2fe6509bc2a35be39e98a9a6f4b42a5b.HYHIUKd7PsPl6qNRgn0zkeWdwRarVgNu",
        model: "deepseek-ai/DeepSeek-V3-0324"
      }
    ];

    // State variables
    let history = []; // Current chat session's message history
    let isProcessing = false; // Flag to prevent multiple concurrent requests
    let currentChatId = null; // ID of the currently active chat
    let chats = []; // Array of all chat sessions stored
    let isMobile = window.innerWidth <= 768; // Detect mobile viewport

    // Initialize application on DOM content loaded
    document.addEventListener('DOMContentLoaded', initApp);

    /**
     * Initializes the application by setting up event listeners,
     * loading modes, and handling chat history.
     */
    async function initApp() {
      setupEventListeners();
      loadTheme(); // Load saved theme preference
      await loadModes(); // Load AI modes from Supabase
      loadChatHistory(); // Load saved chats
      startNewChat(); // Always start a new chat when the app loads
      userInput.focus(); // Focus on the input field
      adjustInputHeight(); // Adjust textarea height on load
      
      // Hide sidebar by default on mobile
      if (isMobile) {
        sidebar.classList.remove('open');
      } else {
        sidebar.classList.add('open'); // Ensure sidebar is open on desktop
      }
    }

    /**
     * Sets up all necessary event listeners for UI interactions.
     */
    function setupEventListeners() {
      sidebarToggle.addEventListener('click', toggleSidebar); // Sidebar toggle button
      newChatBtn.addEventListener('click', handleNewChat); // New chat button
      sendButton.addEventListener('click', sendMessage); // Send message button
      
      // Send message on Enter key press, adjust height on input
      userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
      userInput.addEventListener('input', adjustInputHeight); // Adjust textarea height dynamically

      window.addEventListener('resize', handleResize); // Handle window resize for responsiveness

      // Dark Mode Toggles
      darkModeToggle.addEventListener('click', toggleDarkMode);
      darkModeToggleDesktop.addEventListener('click', toggleDarkMode);

      // Scroll to Bottom button
      chatbox.addEventListener('scroll', handleChatboxScroll);
      scrollToBottomBtn.addEventListener('click', () => {
          chatbox.scrollTop = chatbox.scrollHeight;
      });
    }

    /**
     * Dynamically adjusts the height of the textarea based on content.
     */
    function adjustInputHeight() {
        userInput.style.height = 'auto'; // Reset height to recalculate
        userInput.style.height = userInput.scrollHeight + 'px'; // Set to scroll height
        // Limit max height to prevent excessive expansion
        const maxHeight = window.innerHeight * 0.2; // Max 20% of viewport height
        if (userInput.scrollHeight > maxHeight) {
            userInput.style.overflowY = 'auto';
            userInput.style.height = maxHeight + 'px';
        } else {
            userInput.style.overflowY = 'hidden';
        }
    }

    /**
     * Toggles the visibility of the sidebar.
     */
    function toggleSidebar() {
      sidebar.classList.toggle('open');
    }

    /**
     * Handles the click event for the "New Chat" button, starting a new chat
     * and closing the sidebar on mobile.
     */
    function handleNewChat() {
      startNewChat();
      if (isMobile) {
        sidebar.classList.remove('open');
      }
    }

    /**
     * Handles window resize events to update the mobile flag and sidebar visibility.
     */
    function handleResize() {
      isMobile = window.innerWidth <= 768;
      if (!isMobile) {
        sidebar.classList.add('open'); // Always show sidebar on desktop
      }
      adjustInputHeight(); // Adjust input height on resize
    }

    // Theme Handling (Dark Mode)

    /**
     * Loads the theme preference from local storage or defaults to system preference.
     */
    function loadTheme() {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
            updateDarkModeToggleIcon(true);
        } else {
            document.documentElement.classList.remove('dark');
            updateDarkModeToggleIcon(false);
        }
    }

    /**
     * Toggles the dark mode on/off and saves the preference.
     */
    function toggleDarkMode() {
        document.documentElement.classList.toggle('dark');
        const isDarkMode = document.documentElement.classList.contains('dark');
        localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
        updateDarkModeToggleIcon(isDarkMode);
    }

    /**
     * Updates the icon of the dark mode toggle buttons.
     * @param {boolean} isDarkMode - True if dark mode is active, false otherwise.
     */
    function updateDarkModeToggleIcon(isDarkMode) {
        const iconClass = isDarkMode ? 'fa-sun' : 'fa-moon';
        darkModeToggle.querySelector('i').className = `fas ${iconClass}`;
        darkModeToggleDesktop.querySelector('i').className = `fas ${iconClass}`;
    }

    // Chat History Functions

    /**
     * Loads chat history from local storage.
     */
    function loadChatHistory() {
      const savedChats = localStorage.getItem('takaAiChats');
      if (savedChats) {
        chats = JSON.parse(savedChats);
      } else {
        chats = []; // Initialize as empty array if no saved chats
      }
      renderChatHistory(); // Render the history regardless of initial state
    }

    /**
     * Renders (or re-renders) the list of chat sessions in the sidebar.
     */
    function renderChatHistory() {
      chatHistory.innerHTML = ''; // Clear existing history
      
      // Iterate through chats and create UI elements for each
      chats.forEach(chat => {
        const chatItem = document.createElement('div');
        chatItem.className = 'chat-item';
        chatItem.innerHTML = `
            <span class="truncate">${chat.title || `Chat ${formatDate(chat.createdAt)}`}</span>
            <button class="delete-chat-btn" data-chat-id="${chat.id}">
                <i class="fas fa-trash-alt"></i>
            </button>
        `;
        chatItem.dataset.chatId = chat.id; // Store chat ID for easy lookup
        
        // Mark the active chat
        if (chat.id === currentChatId) {
          chatItem.classList.add('active');
        }
        
        // Add event listener to load chat when clicked (on the text part)
        chatItem.querySelector('span').addEventListener('click', () => {
          loadChat(chat.id);
          if (isMobile) {
            sidebar.classList.remove('open'); // Close sidebar on mobile after selection
          }
        });

        // Add event listener for delete button
        chatItem.querySelector('.delete-chat-btn').addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent loading chat when deleting
            if (confirm("Are you sure you want to delete this chat?")) {
                deleteChat(chat.id);
            }
        });
        
        chatHistory.appendChild(chatItem);
      });
    }

    /**
     * Starts a new chat session, generates a new ID, and adds it to history.
     */
    function startNewChat() {
      const newChatId = Date.now().toString(); // Unique ID for the new chat
      currentChatId = newChatId; // Set as current chat
      
      // Create a new chat object
      const newChat = {
        id: newChatId,
        title: 'New Chat', // Default title
        createdAt: new Date().toISOString(),
        messages: [] // Empty message array for the new chat
      };
      
      chats.unshift(newChat); // Add new chat to the beginning of the list
      saveChats(); // Save updated chats to local storage
      renderChatHistory(); // Re-render sidebar to show new chat
      
      chatbox.innerHTML = ''; // Clear chat display area
      history = []; // Reset current session history
      updateModeDesc(); // Update mode description/greeting for the new chat
      userInput.value = ''; // Clear input field
      adjustInputHeight(); // Reset input height
      chatbox.scrollTop = chatbox.scrollHeight; // Scroll to bottom
    }

    /**
     * Loads a specific chat session by its ID into the main chat area.
     * @param {string} chatId - The ID of the chat to load.
     */
    function loadChat(chatId) {
      const chat = chats.find(c => c.id === chatId);
      if (!chat) return; // Exit if chat not found
      
      currentChatId = chatId; // Set current chat ID
      renderChatHistory(); // Update sidebar to reflect active chat
      
      chatbox.innerHTML = ''; // Clear current chat display
      history = []; // Reset current session history
      userInput.value = ''; // Clear input field
      adjustInputHeight(); // Reset input height

      // Populate chatbox and history with loaded messages
      chat.messages.forEach(msg => {
        addBubble(msg.content, msg.role === 'user' ? 'user' : 'bot', false); // Add bubble without animation for loaded messages
        history.push({
          role: msg.role,
          content: msg.content
        });
      });
      
      // If the loaded chat is empty, show the mode's welcome message
      if (chat.messages.length === 0) {
        updateModeDesc();
      }
      
      chatbox.scrollTop = chatbox.scrollHeight; // Scroll to bottom
    }

    /**
     * Deletes a chat session from history.
     * @param {string} chatId - The ID of the chat to delete.
     */
    function deleteChat(chatId) {
        chats = chats.filter(chat => chat.id !== chatId);
        saveChats();
        renderChatHistory();

        // If the deleted chat was the current one, load a new chat or the first available one
        if (currentChatId === chatId) {
            if (chats.length > 0) {
                loadChat(chats[0].id);
            } else {
                startNewChat(); // Start a brand new chat if no others exist
            }
        }
    }

    /**
     * Saves the current chat sessions array to local storage.
     */
    function saveChats() {
      localStorage.setItem('takaAiChats', JSON.stringify(chats));
    }

    /**
     * Formats a date string into a readable format.
     * @param {string} dateString - The date string to format.
     * @returns {string} The formatted date and time.
     */
    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    }

    // Mode Handling

    /**
     * Loads available AI modes from Supabase and sets up real-time updates.
     */
    async function loadModes() {
      try {
        const { data } = await supabase.from("modes")
          .select("name, description, model, greeting, enabled")
          .eq("enabled", true)
          .order("created_at", { ascending: false });
        
        modeSelect.innerHTML = ''; // Clear existing options
        
        if (data?.length) {
          data.forEach(mode => {
            const option = new Option(mode.name, mode.name);
            option.dataset.desc = mode.description || '';
            option.dataset.greeting = mode.greeting || `Hello! I'm TAKA AI in ${mode.name} mode. How can I help you today?`;
            option.dataset.model = mode.model || 'deepseek-ai/DeepSeek-V3-0324';
            modeSelect.add(option);
          });
          
          // Setup realtime updates for mode changes in Supabase
          supabase.channel('schema-db-changes')
            .on(
              'postgres_changes',
              {
                event: '*',
                schema: 'public',
                table: 'modes'
              },
              (payload) => {
                console.log('Change detected in modes, reloading...');
                loadModes(); // Reload modes on change
              }
            )
            .subscribe();
        } else {
          addDefaultMode(); // Add a default mode if no modes are found
        }
        
        updateModeDesc(); // Update description based on selected mode
      } catch (error) {
        console.error("Error loading modes:", error);
        addDefaultMode(); // Fallback to default mode on error
      }
    }

    /**
     * Adds a default AI mode option to the select dropdown.
     */
    function addDefaultMode() {
      const defaultOption = new Option("Default", "Default");
      defaultOption.dataset.greeting = "Hello! I'm TAKA AI. How can I help you today?";
      defaultOption.dataset.desc = "Default Mode";
      defaultOption.dataset.model = "deepseek-ai/DeepSeek-V3-0324";
      modeSelect.add(defaultOption);
    }

    /**
     * Updates the mode description displayed below the title,
     * and shows a welcome message if the current chat is new.
     */
    function updateModeDesc() {
      const selected = modeSelect.selectedOptions[0];
      const greeting = selected?.dataset?.greeting || "Hello! I'm TAKA AI. How can I help you today?";
      const fullDesc = selected?.dataset?.desc || "Default Mode";
      
      // Extract text between square brackets for the description display
      const bracketedText = fullDesc.match(/\[(.*?)\]/)?.[1] || '';
      modeDescBox.textContent = bracketedText;
      
      // Only display the welcome message if the current chat has no messages
      const currentChat = chats.find(c => c.id === currentChatId);
      if (currentChat && currentChat.messages.length === 0) {
        chatbox.innerHTML = ''; // Clear chatbox first
        addBubble(greeting, "bot", false); // Add greeting without animation
      }
    }

    // Event listener for mode change
    modeSelect.addEventListener("change", updateModeDesc);

    // Chat Functions

    /**
     * Adds a chat bubble to the display area.
     * @param {string} text - The text content of the bubble.
     * @param {'user'|'bot'} type - The type of bubble (user or bot).
     * @param {boolean} [animateText=true] - Whether to animate the text display for bot messages.
     */
    function addBubble(text, type, animateText = true) {
      const container = document.createElement("div");
      container.className = "bubble-container";
      
      if (type === "bot") {
        container.innerHTML = `
          <img src="avatar.png" class="avatar" alt="Bot Avatar">
          <div class="bubble bot-bubble"></div>
          <button class="copy-btn"><i class="fas fa-copy"></i> Copy</button>
        `;
      } else {
        container.innerHTML = `
          <div style="width: 35px"></div> <!-- Placeholder for avatar alignment -->
          <div class="bubble user-bubble"></div>
        `;
      }

      const bubble = container.querySelector('.bubble');
      chatbox.appendChild(container);

      // Markdown rendering for bot messages
      if (type === "bot") {
          const renderedHtml = marked.parse(text);
          if (animateText) {
              let i = 0;
              const charactersPerFrame = 10; // Even faster animation
              const animate = () => {
                  if (i < renderedHtml.length) {
                      // Append characters directly as HTML, avoid using innerText
                      bubble.innerHTML = renderedHtml.substring(0, i + charactersPerFrame);
                      i += charactersPerFrame;
                      requestAnimationFrame(animate);
                  } else {
                      bubble.innerHTML = renderedHtml; // Ensure full content is rendered
                  }
                  chatbox.scrollTop = chatbox.scrollHeight; // Keep scrolling to bottom
              };
              animate();
          } else {
              bubble.innerHTML = renderedHtml; // Directly set HTML for loaded messages
              chatbox.scrollTop = chatbox.scrollHeight;
          }

          // Attach copy event listener to the copy button
          const copyBtn = container.querySelector('.copy-btn');
          if (copyBtn) {
              copyBtn.addEventListener('click', () => copyToClipboard(text, copyBtn));
          }
      } else {
        bubble.textContent = text; // Directly set text for user bubbles
        chatbox.scrollTop = chatbox.scrollHeight;
      }
    }

    /**
     * Copies text to the clipboard. Provides fallback for iframe environments.
     * @param {string} text - The text to copy.
     * @param {HTMLElement} button - The button element that triggered the copy.
     */
    function copyToClipboard(text, button) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
                showCopyFeedback(button);
            }).catch(err => {
                console.error('Failed to copy using clipboard API:', err);
                fallbackCopyTextToClipboard(text, button);
            });
        } else {
            fallbackCopyTextToClipboard(text, button);
        }
    }

    /**
     * Fallback method for copying text using `document.execCommand`.
     * @param {string} text - The text to copy.
     * @param {HTMLElement} button - The button element that triggered the copy.
     */
    function fallbackCopyTextToClipboard(text, button) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed'; // Avoid scrolling to bottom
        textarea.style.left = '-9999px';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        try {
            document.execCommand('copy');
            showCopyFeedback(button);
        } catch (err) {
            console.error('Failed to copy with fallback:', err);
            // You might want to show a message to the user that copying failed
        } finally {
            document.body.removeChild(textarea);
        }
    }

    /**
     * Shows visual feedback when text is copied.
     * @param {HTMLElement} button - The button element to update.
     */
    function showCopyFeedback(button) {
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-check"></i> Copied!';
        setTimeout(() => {
            button.innerHTML = originalText;
        }, 1500); // Display "Copied!" for 1.5 seconds
    }

    /**
     * Sends the user's message to the AI and handles the response.
     */
    async function sendMessage() {
      const message = userInput.value.trim();
      if (!message || isProcessing) return; // Prevent sending empty messages or during processing

      userInput.value = ""; // Clear input field
      adjustInputHeight(); // Reset input height
      isProcessing = true; // Set processing flag
      sendButton.disabled = true; // Disable send button

      addBubble(message, "user"); // Add user's message to chatbox

      // Ensure there's a current chat session; if not, create one
      if (!currentChatId) {
        startNewChat();
      }

      const currentChat = chats.find(c => c.id === currentChatId);
      
      // Set chat title if it's the first message in a new chat
      if (currentChat.messages.length === 0) {
        currentChat.title = message.length > 30 ? 
          message.substring(0, 30) + '...' : message;
        saveChats();
        renderChatHistory(); // Update sidebar with new title
      }

      // Add user message to the current chat's history
      currentChat.messages.push({
        role: 'user',
        content: message,
        timestamp: new Date().toISOString()
      });
      saveChats(); // Save updated chat history

      // Display typing indicator
      const thinking = document.createElement("div");
      thinking.className = "typing";
      thinking.id = "thinking";
      thinking.textContent = "TAKA AI is thinking";
      chatbox.appendChild(thinking);
      chatbox.scrollTop = chatbox.scrollHeight;

      try {
        const selectedOption = modeSelect.selectedOptions[0];
        // Construct system message based on selected AI mode
        const systemMessage = `You are TAKA AI. ${selectedOption?.dataset?.greeting || "You are a helpful assistant."}`;
        
        let response = null;
        // Attempt to fetch response from multiple API configurations for robustness
        for (const apiConfig of API_CONFIGS) {
          try {
            response = await fetchAPI({
              endpoint: apiConfig.endpoint,
              apiKey: apiConfig.apiKey,
              model: selectedOption?.dataset?.model || apiConfig.model,
              systemMessage,
              message,
              history // Pass current session history for context
            });
            
            if (response) break; // Break if a successful response is received
          } catch (err) {
            console.error(`API ${apiConfig.endpoint} failed:`, err);
            continue; // Try next API on failure
          }
        }

        if (!response) {
          throw new Error("All APIs failed"); // If all APIs fail, throw error
        }

        // Extract bot's reply from the response
        const reply = response.choices?.[0]?.message?.content || "I couldn't generate a response. Please try again.";
        
        // Update session history and current chat's messages
        history.push({ role: "user", content: message });
        history.push({ role: "assistant", content: reply });
        
        currentChat.messages.push({
          role: 'assistant',
          content: reply,
          timestamp: new Date().toISOString()
        });
        saveChats(); // Save updated chat history
        
        document.getElementById("thinking")?.remove(); // Remove thinking indicator
        addBubble(reply, "bot"); // Add bot's reply to chatbox with animation
        
      } catch (err) {
        console.error("All API attempts failed:", err);
        document.getElementById("thinking")?.remove();
        addBubble(
          "⚠️ All AI services are currently unavailable. Please try again later.", 
          "bot"
        );
      } finally {
        isProcessing = false; // Reset processing flag
        sendButton.disabled = false; // Re-enable send button
      }
    }

    /**
     * Fetches a response from the AI API.
     * @param {object} options - Configuration for the API call.
     * @param {string} options.endpoint - The API endpoint URL.
     * @param {string} options.apiKey - The API key.
     * @param {string} options.model - The AI model to use.
     * @param {string} options.systemMessage - The system message for the AI.
     * @param {string} options.message - The user's current message.
     * @param {Array<object>} options.history - The chat history for context.
     * @returns {Promise<object>} The JSON response from the API.
     * @throws {Error} If the API request fails or times out.
     */
    async function fetchAPI({endpoint, apiKey, model, systemMessage, message, history}) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000); // 15-second timeout

      const res = await fetch(endpoint, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model,
          // Send last 6 messages + current user message for context
          messages: [
            { role: "system", content: systemMessage },
            ...history.slice(-6), 
            { role: "user", content: message }
          ],
          temperature: 0.7 // Creativity level
        }),
        signal: controller.signal // Apply timeout signal
      });

      clearTimeout(timeoutId); // Clear timeout if response received in time
      
      if (!res.ok) {
        const errorData = await res.json();
        console.error('API Error:', errorData);
        throw new Error(`API Error: ${res.status} ${res.statusText}`);
      }
      
      return await res.json();
    }

    /**
     * Handles the scroll event of the chatbox to show/hide the scroll to bottom button.
     */
    function handleChatboxScroll() {
        if (chatbox.scrollHeight - chatbox.scrollTop > chatbox.clientHeight + 100) { // If scrolled up by more than 100px
            scrollToBottomBtn.classList.add('show');
        } else {
            scrollToBottomBtn.classList.remove('show');
        }
    }
  </script>
</body>
</html>

